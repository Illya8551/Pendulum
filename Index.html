<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Double Stick Animation</title>
<style>
  body { 
    margin:0; 
    background:#000; 
    overflow:hidden; 
    font-family: Arial, sans-serif;
  }
  canvas { 
    display:block; 
  }
  
  .controls {
    position: absolute;
    top: 20px;
    left: 20px;
    background: rgba(30, 30, 30, 0.8);
    padding: 20px;
    border-radius: 10px;
    color: white;
    z-index: 100;
    max-width: 320px;
    transition: all 0.3s ease;
  }
  
  .controls.hidden {
    opacity: 0.3;
    transform: translateX(-90%);
  }
  
  .controls.hidden:hover {
    opacity: 0.9;
    transform: translateX(0);
  }
  
  .toggle-menu {
    position: absolute;
    top: 10px;
    right: 10px;
    background: #555;
    color: white;
    border: none;
    width: 30px;
    height: 30px;
    border-radius: 50%;
    cursor: pointer;
    font-size: 18px;
    z-index: 101;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    line-height: 1;
  }
  
  .control-group {
    margin-bottom: 15px;
  }
  
  label {
    display: block;
    color: #ccc;
    margin-bottom: 5px;
  }
  
  input[type="range"] {
    width: 100%;
    margin: 5px 0;
  }
  
  .reset-buttons-group {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 8px;
    margin-top: 10px;
  }
  
  .button-group {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-top: 10px;
  }
  
  button {
    background: #4CAF50;
    color: white;
    border: none;
    padding: 8px 12px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 13px;
    flex: 1;
    text-align: center;
    min-height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  button:hover {
    opacity: 0.9;
  }
  
  .reset-sticks-btn {
    background: #2196F3;
  }
  
  .reset-settings-btn {
    background: #9C27B0;
  }
  
  .reset-trail-btn {
    background: #FF9800;
  }
  
  .reset-both-btn {
    background: #FF5722;
  }
  
  .reset-all-btn {
    background: #f44336;
  }
  
  .toggle-menu-btn {
    background: #555;
    flex: 0;
    min-width: 70px;
  }
  
  .hide-sticks-btn {
    background: #607D8B;
  }
  
  .value-display {
    display: inline-block;
    margin-left: 10px;
    color: #4CAF50;
    font-weight: bold;
    min-width: 50px;
  }
  
  .info {
    font-size: 12px;
    color: #888;
    margin-top: 5px;
  }
  
  .checkbox-group {
    display: flex;
    align-items: center;
    margin-top: 10px;
  }
  
  .checkbox-group input {
    width: auto;
    margin-right: 10px;
  }
  
  .performance-info {
    position: absolute;
    bottom: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.7);
    color: #0f0;
    padding: 10px;
    border-radius: 5px;
    font-family: monospace;
    font-size: 12px;
    z-index: 99;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>

<button class="toggle-menu" id="toggleMenuBtn">☰</button>

<div class="controls" id="controlsPanel">
  <div class="control-group">
    <label for="speedSlider">Speed Multiplier: <span id="speedValue" class="value-display">1.0x</span></label>
    <input type="range" id="speedSlider" min="0" max="200" value="100" step="1">
    <div class="info">Increases stick rotation speed AND point frequency</div>
  </div>
  
  <div class="control-group">
    <label for="angle1Speed">First Stick Speed: <span id="angle1Value" class="value-display">0.02</span></label>
    <input type="range" id="angle1Speed" min="0" max="100" value="20" step="1">
  </div>
  
  <div class="control-group">
    <label for="angle2Speed">Second Stick Speed: <span id="angle2Value" class="value-display">0.0628</span></label>
    <input type="range" id="angle2Speed" min="0" max="300" value="63" step="1">
  </div>
  
  <div class="control-group">
    <label for="stickLength">Stick Length: <span id="lengthValue" class="value-display">150</span></label>
    <input type="range" id="stickLength" min="10" max="500" value="150" step="1">
  </div>
  
  <div class="control-group">
    <label for="pointDistance">Point Distance: <span id="distanceValue" class="value-display">1.0</span></label>
    <input type="range" id="pointDistance" min="0.1" max="10" value="1.0" step="0.1">
    <div class="info">Higher = fewer points, sharper angles</div>
    
    <div class="checkbox-group">
      <input type="checkbox" id="adaptivePoints" checked>
      <label for="adaptivePoints">Adaptive to speed</label>
    </div>
  </div>
  
  <div class="reset-buttons-group">
    <button class="reset-sticks-btn" id="resetSticksBtn">Reset Sticks</button>
    <button class="reset-settings-btn" id="resetSettingsBtn">Reset Settings</button>
    <button class="reset-trail-btn" id="resetTrailBtn">Reset Trail</button>
    <button class="reset-both-btn" id="resetBothBtn">Reset Both</button>
  </div>
  
  <div class="button-group">
    <button id="pauseBtn">Pause</button>
    <button id="qualityBtn">Quality Mode</button>
    <button class="hide-sticks-btn" id="hideSticksBtn">Hide Sticks</button>
    <button class="reset-all-btn" id="resetAllBtn">Reset All</button>
    <button class="toggle-menu-btn" id="hideMenuBtn">Hide</button>
  </div>
  
  <div class="info">
    Points in trail: <span id="trailPoints">0</span>
    <span id="sticksStatus"> | Sticks: ON</span>
    <span id="qualityStatus"> | Quality: HIGH</span>
  </div>
</div>

<div class="performance-info" id="performanceInfo">
  FPS: <span id="fpsCounter">60</span><br>
  Trail: <span id="trailCounter">0</span><br>
  Sticks: <span id="sticksCounter">ON</span><br>
  Quality: <span id="qualityCounter">HIGH</span>
</div>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

// Canvas dimensions
function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.onresize = resize;

// Control elements
const speedSlider = document.getElementById("speedSlider");
const speedValue = document.getElementById("speedValue");
const angle1Slider = document.getElementById("angle1Speed");
const angle1Value = document.getElementById("angle1Value");
const angle2Slider = document.getElementById("angle2Speed");
const angle2Value = document.getElementById("angle2Value");
const stickLengthSlider = document.getElementById("stickLength");
const lengthValue = document.getElementById("lengthValue");
const pointDistanceSlider = document.getElementById("pointDistance");
const distanceValue = document.getElementById("distanceValue");
const adaptivePointsCheckbox = document.getElementById("adaptivePoints");
const pauseBtn = document.getElementById("pauseBtn");
const qualityBtn = document.getElementById("qualityBtn");
const resetSticksBtn = document.getElementById("resetSticksBtn");
const resetSettingsBtn = document.getElementById("resetSettingsBtn");
const resetTrailBtn = document.getElementById("resetTrailBtn");
const resetBothBtn = document.getElementById("resetBothBtn");
const resetAllBtn = document.getElementById("resetAllBtn");
const hideSticksBtn = document.getElementById("hideSticksBtn");
const hideMenuBtn = document.getElementById("hideMenuBtn");
const toggleMenuBtn = document.getElementById("toggleMenuBtn");
const controlsPanel = document.getElementById("controlsPanel");
const trailPoints = document.getElementById("trailPoints");
const sticksStatus = document.getElementById("sticksStatus");
const qualityStatus = document.getElementById("qualityStatus");
const fpsCounter = document.getElementById("fpsCounter");
const trailCounter = document.getElementById("trailCounter");
const sticksCounter = document.getElementById("sticksCounter");
const qualityCounter = document.getElementById("qualityCounter");

// Animation parameters
let L = 150; // Stick length
let angle1 = 0;
let angle2 = 0;
let baseSpeed1 = 0.02;
let baseSpeed2 = baseSpeed1 * 3.14;
let speedMultiplier = 1.0;
let minPointDistance = 1.0; // Minimum distance between points
let adaptivePoints = true;
let isPaused = false;
let showSticks = true; // Whether to show sticks and point
let trail = []; // No length limit
let lastPoint = null; // Last added point
let isMenuVisible = true;
let lastTime = 0;
let frameCount = 0;
let fps = 60;

// Quality modes
let highQualityMode = true; // HIGH quality - full smoothing, LOW quality - FPS optimization
let optimizedTrail = []; // For LOW quality mode
let lastOptimizationTime = 0;
let optimizationInterval = 100; // Optimize every 100ms

// For point frequency control
let pointAddCounter = 0;
let pointAddThreshold = 1; // Default: add point every frame

// Default values
const DEFAULT_VALUES = {
  L: 150,
  baseSpeed1: 0.02,
  baseSpeed2: 0.02 * 3.14,
  speedMultiplier: 1.0,
  minPointDistance: 1.0,
  adaptivePoints: true,
  angle1Slider: 20,
  angle2Slider: 63,
  speedSlider: 100,
  stickLengthSlider: 150,
  pointDistanceSlider: 1.0,
  showSticks: true,
  highQualityMode: true
};

// Function to calculate distance between points
function distance(x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  return Math.sqrt(dx * dx + dy * dy);
}

// Optimization for LOW quality mode - trail simplification
function optimizeTrailForPerformance() {
  if (trail.length < 2) {
    optimizedTrail = [...trail];
    return;
  }
  
  // Use algorithm to remove points on straight segments
  const simplified = [];
  const tolerance = 2.0; // Simplification tolerance
  
  simplified.push(trail[0]);
  
  // Skip intermediate points on relatively straight segments
  for (let i = 1; i < trail.length - 1; i++) {
    const prev = simplified[simplified.length - 1];
    const current = trail[i];
    const next = trail[i + 1];
    
    // Check how much the point deviates from a straight line
    const area = Math.abs(
      (prev.x * (current.y - next.y) + 
       current.x * (next.y - prev.y) + 
       next.x * (prev.y - current.y)) / 2
    );
    
    const base = distance(prev.x, prev.y, next.x, next.y);
    
    // If deviation is significant, keep the point
    if (base === 0 || area / base > tolerance) {
      simplified.push(current);
    }
  }
  
  // Always add the last point
  if (trail.length > 0) {
    simplified.push(trail[trail.length - 1]);
  }
  
  // Limit optimized trail size
  const maxPoints = 1000;
  if (simplified.length > maxPoints) {
    // Take every Nth point
    const step = Math.ceil(simplified.length / maxPoints);
    optimizedTrail = [];
    for (let i = 0; i < simplified.length; i += step) {
      optimizedTrail.push(simplified[i]);
    }
    optimizedTrail.push(simplified[simplified.length - 1]);
  } else {
    optimizedTrail = simplified;
  }
}

// Update display values
function updateDisplays() {
  speedValue.textContent = speedMultiplier.toFixed(1) + "x";
  angle1Value.textContent = baseSpeed1.toFixed(4);
  angle2Value.textContent = baseSpeed2.toFixed(4);
  lengthValue.textContent = L;
  distanceValue.textContent = minPointDistance.toFixed(1);
  trailPoints.textContent = trail.length.toLocaleString();
  trailCounter.textContent = trail.length.toLocaleString();
  
  // Update sticks status
  const sticksText = showSticks ? "ON" : "OFF";
  sticksStatus.textContent = ` | Sticks: ${sticksText}`;
  sticksCounter.textContent = sticksText;
  
  // Update quality status
  const qualityText = highQualityMode ? "HIGH" : "LOW";
  qualityStatus.textContent = ` | Quality: ${qualityText}`;
  qualityCounter.textContent = qualityText;
  qualityBtn.textContent = highQualityMode ? "Performance Mode" : "Quality Mode";
  
  // Update button text
  hideSticksBtn.textContent = showSticks ? "Hide Sticks" : "Show Sticks";
  hideMenuBtn.textContent = isMenuVisible ? "Hide" : "Show";
  toggleMenuBtn.textContent = isMenuVisible ? "✕" : "☰";
}

// Slider event handlers
speedSlider.addEventListener('input', function() {
  speedMultiplier = this.value / 100;
  // Update point addition threshold based on speed
  pointAddThreshold = Math.max(0.1, 1 / speedMultiplier);
  updateDisplays();
});

angle1Slider.addEventListener('input', function() {
  baseSpeed1 = this.value / 1000;
  baseSpeed2 = baseSpeed1 * 3.14;
  updateDisplays();
});

angle2Slider.addEventListener('input', function() {
  baseSpeed2 = this.value / 1000;
  updateDisplays();
});

stickLengthSlider.addEventListener('input', function() {
  L = parseInt(this.value);
  updateDisplays();
});

pointDistanceSlider.addEventListener('input', function() {
  minPointDistance = parseFloat(this.value);
  updateDisplays();
});

adaptivePointsCheckbox.addEventListener('change', function() {
  adaptivePoints = this.checked;
});

// Control buttons
pauseBtn.addEventListener('click', function() {
  isPaused = !isPaused;
  pauseBtn.textContent = isPaused ? "Resume" : "Pause";
});

// Quality mode toggle
qualityBtn.addEventListener('click', function() {
  highQualityMode = !highQualityMode;
  if (!highQualityMode) {
    // Optimize trail when switching to performance mode
    optimizeTrailForPerformance();
  }
  updateDisplays();
});

// Hide/show sticks
hideSticksBtn.addEventListener('click', function() {
  showSticks = !showSticks;
  updateDisplays();
});

// Reset only sticks
resetSticksBtn.addEventListener('click', function() {
  angle1 = 0;
  angle2 = 0;
  updateDisplays();
});

// Reset only settings
resetSettingsBtn.addEventListener('click', function() {
  speedMultiplier = DEFAULT_VALUES.speedMultiplier;
  baseSpeed1 = DEFAULT_VALUES.baseSpeed1;
  baseSpeed2 = DEFAULT_VALUES.baseSpeed2;
  L = DEFAULT_VALUES.L;
  minPointDistance = DEFAULT_VALUES.minPointDistance;
  adaptivePoints = DEFAULT_VALUES.adaptivePoints;
  highQualityMode = DEFAULT_VALUES.highQualityMode;
  
  speedSlider.value = DEFAULT_VALUES.speedSlider;
  angle1Slider.value = DEFAULT_VALUES.angle1Slider;
  angle2Slider.value = DEFAULT_VALUES.angle2Slider;
  stickLengthSlider.value = DEFAULT_VALUES.stickLengthSlider;
  pointDistanceSlider.value = DEFAULT_VALUES.pointDistanceSlider;
  adaptivePointsCheckbox.checked = DEFAULT_VALUES.adaptivePoints;
  
  // Reset point addition threshold
  pointAddThreshold = 1;
  
  updateDisplays();
});

// Reset only trail
resetTrailBtn.addEventListener('click', function() {
  trail = [];
  optimizedTrail = [];
  lastPoint = null;
  updateDisplays();
});

// Reset both sticks and trail
resetBothBtn.addEventListener('click', function() {
  angle1 = 0;
  angle2 = 0;
  trail = [];
  optimizedTrail = [];
  lastPoint = null;
  updateDisplays();
});

// Reset everything
resetAllBtn.addEventListener('click', function() {
  // Reset positions and trail
  angle1 = 0;
  angle2 = 0;
  trail = [];
  optimizedTrail = [];
  lastPoint = null;
  
  // Reset settings
  speedMultiplier = DEFAULT_VALUES.speedMultiplier;
  baseSpeed1 = DEFAULT_VALUES.baseSpeed1;
  baseSpeed2 = DEFAULT_VALUES.baseSpeed2;
  L = DEFAULT_VALUES.L;
  minPointDistance = DEFAULT_VALUES.minPointDistance;
  adaptivePoints = DEFAULT_VALUES.adaptivePoints;
  showSticks = DEFAULT_VALUES.showSticks;
  highQualityMode = DEFAULT_VALUES.highQualityMode;
  
  // Reset sliders
  speedSlider.value = DEFAULT_VALUES.speedSlider;
  angle1Slider.value = DEFAULT_VALUES.angle1Slider;
  angle2Slider.value = DEFAULT_VALUES.angle2Slider;
  stickLengthSlider.value = DEFAULT_VALUES.stickLengthSlider;
  pointDistanceSlider.value = DEFAULT_VALUES.pointDistanceSlider;
  adaptivePointsCheckbox.checked = DEFAULT_VALUES.adaptivePoints;
  
  // Reset state
  isPaused = false;
  pauseBtn.textContent = "Pause";
  pointAddThreshold = 1;
  
  updateDisplays();
});

// Hide/show menu
hideMenuBtn.addEventListener('click', function() {
  toggleMenu();
});

toggleMenuBtn.addEventListener('click', function() {
  toggleMenu();
});

function toggleMenu() {
  isMenuVisible = !isMenuVisible;
  controlsPanel.classList.toggle('hidden', !isMenuVisible);
  updateDisplays();
}

// Main animation function
function draw(timestamp) {
  // Request next frame
  requestAnimationFrame(draw);
  
  // Calculate FPS
  frameCount++;
  if (timestamp >= lastTime + 1000) {
    fps = Math.round((frameCount * 1000) / (timestamp - lastTime));
    fpsCounter.textContent = fps;
    frameCount = 0;
    lastTime = timestamp;
  }
  
  // Center of screen
  const cx = canvas.width / 2;
  const cy = canvas.height / 2;

  // Update angles if not paused - apply speed multiplier
  if (!isPaused) {
    // Multiply base speeds by speed multiplier
    const actualSpeed1 = baseSpeed1 * speedMultiplier;
    const actualSpeed2 = baseSpeed2 * speedMultiplier;
    
    angle1 += actualSpeed1;
    angle2 += actualSpeed2;
    
    // Periodic optimization in performance mode
    if (!highQualityMode && timestamp - lastOptimizationTime > optimizationInterval) {
      optimizeTrailForPerformance();
      lastOptimizationTime = timestamp;
    }
  }

  // Stick end coordinates
  const x1 = cx + Math.cos(angle1) * L;
  const y1 = cy + Math.sin(angle1) * L;

  const x2 = x1 + Math.cos(angle2) * L;
  const y2 = y1 + Math.sin(angle2) * L;

  // Clear screen
  ctx.fillStyle = "#000000";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Add point to trail considering minimum distance AND speed
  if (!isPaused) {
    // Increase counter for point frequency control
    pointAddCounter += speedMultiplier;
    
    // Check if we should add a point this frame
    if (pointAddCounter >= pointAddThreshold) {
      pointAddCounter -= pointAddThreshold;
      
      let shouldAddPoint = true;
      
      // Check distance to last point
      if (lastPoint) {
        const dist = distance(x2, y2, lastPoint.x, lastPoint.y);
        
        // Adapt minimum distance to speed
        let effectiveDistance = minPointDistance;
        if (adaptivePoints) {
          // At high speed we can reduce distance between points
          // for denser trail, but not too much
          effectiveDistance = minPointDistance / Math.max(1, speedMultiplier * 0.5);
        }
        
        if (dist < effectiveDistance) {
          shouldAddPoint = false;
        }
      }
      
      if (shouldAddPoint) {
        const newPoint = {x: x2, y: y2};
        trail.push(newPoint);
        lastPoint = newPoint;
      }
    }
  }

  // Draw trail depending on quality mode
  const pointsToDraw = highQualityMode ? trail : optimizedTrail;
  
  if (pointsToDraw.length > 1) {
    
    if (highQualityMode) {
      // HIGH QUALITY MODE - Smooth lines with anti-aliasing
      ctx.strokeStyle = "white";
      ctx.lineWidth = 2;
      ctx.lineJoin = "round"; // Rounded corners for smoothness
      ctx.lineCap = "round"; // Rounded ends
      ctx.beginPath();
      ctx.moveTo(pointsToDraw[0].x, pointsToDraw[0].y);
      
      // Draw all points for maximum quality
      for(let i = 1; i < pointsToDraw.length; i++){
        ctx.lineTo(pointsToDraw[i].x, pointsToDraw[i].y);
      }
      
      ctx.stroke();
      
      // Add light glow effect only to last segment
      if (pointsToDraw.length > 2) {
        const lastIndex = pointsToDraw.length - 1;
        ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(pointsToDraw[lastIndex - 1].x, pointsToDraw[lastIndex - 1].y);
        ctx.lineTo(pointsToDraw[lastIndex].x, pointsToDraw[lastIndex].y);
        ctx.stroke();
      }
    } else {
      // LOW QUALITY / PERFORMANCE MODE - Angular lines for better FPS
      ctx.strokeStyle = "white";
      ctx.lineWidth = 2;
      ctx.lineJoin = "miter"; // Sharp corners
      ctx.lineCap = "butt"; // Straight ends
      ctx.beginPath();
      ctx.moveTo(pointsToDraw[0].x, pointsToDraw[0].y);
      
      // Optimized drawing with point skipping for performance
      let drawStep = 1;
      if (pointsToDraw.length > 500) {
        drawStep = Math.floor(pointsToDraw.length / 250);
      }
      
      for(let i = drawStep; i < pointsToDraw.length; i += drawStep){
        ctx.lineTo(pointsToDraw[i].x, pointsToDraw[i].y);
      }
      
      // Finish with last point
      const lastIdx = pointsToDraw.length - 1;
      if (lastIdx % drawStep !== 0) {
        ctx.lineTo(pointsToDraw[lastIdx].x, pointsToDraw[lastIdx].y);
      }
      
      ctx.stroke();
      
      // Add points at corners for visualization
      if (pointsToDraw.length < 200) {
        ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
        for(let i = 0; i < pointsToDraw.length; i += Math.max(1, Math.floor(pointsToDraw.length / 20))){
          const point = pointsToDraw[i];
          ctx.beginPath();
          ctx.arc(point.x, point.y, 2, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }
  }

  // Draw sticks only if enabled
  if (showSticks) {
    // First stick
    ctx.strokeStyle = "red";
    ctx.lineWidth = 3;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(x1, y1);
    ctx.stroke();

    // Second stick
    ctx.strokeStyle = "cyan";
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();

    // End point
    ctx.fillStyle = "lime";
    ctx.beginPath();
    ctx.arc(x2, y2, 4, 0, Math.PI * 2);
    ctx.fill();
    
    // Light glow effect for point in quality mode
    if (highQualityMode) {
      ctx.fillStyle = "rgba(0, 255, 0, 0.3)";
      ctx.beginPath();
      ctx.arc(x2, y2, 8, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Update point counter every 10 frames
  if (frameCount % 10 === 0) {
    updateDisplays();
  }
}

// Initialization
updateDisplays();
pointAddThreshold = 1; // Initial value

// Start animation
requestAnimationFrame(draw);

// Hotkeys for quick toggling
document.addEventListener('keydown', function(e) {
  if (e.key === 'q' || e.key === 'Q') {
    highQualityMode = !highQualityMode;
    if (!highQualityMode) {
      optimizeTrailForPerformance();
    }
    updateDisplays();
  }
  if (e.key === 's' || e.key === 'S') {
    showSticks = !showSticks;
    updateDisplays();
  }
  if (e.key === 'p' || e.key === 'P') {
    isPaused = !isPaused;
    pauseBtn.textContent = isPaused ? "Resume" : "Pause";
  }
});
</script>
</body>
</html>
